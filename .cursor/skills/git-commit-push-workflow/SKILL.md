---
name: git-commit-push-workflow
description: Enforces a thorough git commit and optional push workflow: always inspect git status and diffs, run basic checks, iterate on fixes until the working tree is clean and issues are resolved, then create a well-structured commit, and only push to GitHub when the user explicitly requests it (e.g., says 提交并推送/push).
---

# Git Commit & Push Workflow

## Instructions

Use this skill whenever the user要求“提交代码”、“生成 commit”、“帮我 commit/push”、“提交到 GitHub”等与提交相关的操作。

当该技能生效时，遵循以下严格流程；**不要跳步**，除非用户明确要求只做其中一部分（例如“先帮我看 diff，不要提交”）：

### 1. 收集当前改动信息

1. 运行并查看：
   - `git status`：了解当前分支、已暂存/未暂存文件、未跟踪文件。
   - `git diff`：查看未暂存改动的详细内容。
   - 如有必要，`git diff --cached`：查看已暂存改动。
   - `git log -5 --oneline`：了解最近提交风格（是否使用 Conventional Commits 等）。
2. 向用户简要总结当前改动范围与状态（例如：新增脚本、修改文档、重构某模块等）。

### 2. 自检与代码审查（review）

在尝试提交之前，始终自行检查并审阅改动：

1. **快速代码审查**：
   - 查找明显问题：死代码、调试输出、硬编码路径、本地绝对路径、本地账号信息等。
   - 特别注意是否包含潜在敏感信息（如 `.env`、密钥、密码、个人路径等）。如发现，**不要提交**，提醒用户处理。
2. **风格与一致性**：
   - 对照项目现有代码风格（命名、注释习惯、目录结构），避免引入明显风格不一致的代码。
3. 如发现问题：
   - 优先在当前会话中提出修复方案并直接修改代码。
   - 修改后**回到第 1 步**，重新收集 `git status` / `git diff`，确认问题已修复。

> 始终保证：在进行后续提交前，明显问题已经在本地修复过一轮。

### 3. 运行检查（lint / 测试）

在条件允许时，应尽量运行项目已有的自动检查：

1. 若项目有明确的测试或脚本（例如 `pytest`、`npm test`、`make test`、`./scripts/check.sh` 等），在执行提交前尽可能运行：
   - 如果在当前上下文已知推荐命令，则优先使用。
   - 若运行失败，阅读错误信息，尝试诊断并修复后**重新运行**，直到通过或用户决定暂时忽略。
2. 对于本次会话中刚刚修改过的文件，可使用项目内的 linter 工具（如 `ReadLints` 对应的规则）检查并修复新引入的问题。

> 原则：**能自动检查的尽量自动检查、能自动修的尽量自动修。**

### 4. 整理提交范围（选择要提交的文件）

1. 根据 `git status` 判断哪些文件应该包含在这次提交中：
   - 相关代码文件、文档、脚本等。
   - 避免把调试文件、临时文件、缓存、数据文件等加进去。
2. 使用 `git add` 只暂存**需要提交的文件**：
   - 如项目较复杂，可以按目录或文件类型分组提交（例如先提交文档，再提交脚本）。
3. `git diff --cached` 再次核对即将提交的内容，确认没有误加文件。

如果发现问题或多余文件：

- 使用 `git restore --staged`/`git restore` 等命令移除或还原；
- 然后再次回到本节重新整理。

### 5. 生成并完善提交信息

1. 通过 `git diff --cached` 分析改动性质，总结为 1–2 句话说明「做了什么」和「为什么」。
2. 参考最近的 `git log`，对齐项目的 commit 风格，例如：
   - 若项目使用 Conventional Commits，可采用如：
     - `docs: update tokenizer basics`
     - `fix: tokenizer docs paths and corpus reader`
3. 编写提交信息时：
   - **标题行**简洁清晰（建议不超过 72 字符）。
   - 如有必要，可在提交体中加入要点说明（本 skill 不强制要求提交体）。

在生成提交信息后，再快速对照 diff，确认描述与实际改动一致。

### 6. 创建本地提交

1. 确认：
   - 需要提交的文件都已暂存；
   - 明显问题已修复；
   - 能运行的检查（测试 / lints）已经尽量跑过。
2. 执行 `git commit`，使用上一步生成的提交信息。
3. 提交后再次运行 `git status`，确认：
   - 工作区干净，或仅剩下预期的未提交改动；
   - 没有遗漏的文件需要包含在这次提交里。

如发现遗漏文件：

- 视情况决定是追加下一次提交，还是在当前会话中额外创建一个补充提交；
- 不在未经用户同意的情况下自动修改历史（例如禁止随意 `commit --amend`）。

### 7. 是否推送到 GitHub（remote push）

遵循以下安全策略，避免意外推送：

1. **仅当用户明确表示需要推送时才 push**，例如用户说：
   - “提交并推送”
   - “帮我 push 到 GitHub”
   - “推到远端/远程仓库”
2. 如果用户只说“提交”或“帮我生成 commit”：
   - 默认只在本地创建提交，不自动推送。
   - 在回复中说明「已在本地提交，如需推送请再说一声」。
3. 当明确需要推送时：
   - 再次用 `git status` 确认本地分支状态（无未提交改动）。
   - 执行 `git push origin <branch>`（通常是 `main` 或当前分支）。
   - 推送成功后，向用户简要报告：
     - 推送的分支名；
     - 大致改动范围；
     - 如有可用的远程链接（例如 GitHub 仓库 URL 或 PR URL），可提示用户在哪里查看。

> 严格避免使用危险操作（如强制推送到主分支等），除非用户明确要求并且给予足够提示。

### 8. 循环与收尾

在整个流程中，如果任一步发现问题（包括：代码误改、检查失败、commit 信息不准确等），应当：

1. 先**修复问题**（修改代码或配置）；
2. 然后**回到合适的上一步**（例如重新跑检查、重新查看 diff）；
3. 直到：
   - diff 与期望一致；
   - 检查尽可能通过；
   - 提交信息准确反映改动；
   - 本地仓库状态清晰可控。

最终再进行（或重新进行）提交与可选推送。

## Examples

### 示例 1：用户要求「帮我提交这次改动」

用户：“帮我提交这次改动。”

代理预期行为：

1. 按本技能说明，先运行并查看 `git status` / `git diff` / `git diff --cached` / `git log -5 --oneline`。
2. 用自然语言向用户简要总结改动内容，并指出是否有可疑文件或潜在问题。
3. 运行项目已有的测试/检查（如合适）。
4. 根据 diff 生成合适的提交信息（对齐现有风格）。
5. `git add` 目标文件，`git commit` 完成本地提交。
6. 回复用户：说明已经在本地完成提交，简要描述提交内容，并提醒「如需推送到 GitHub，请再说一声」。

### 示例 2：用户要求「提交并推送到 GitHub」

用户：“这部分改动帮我提交并推送到 GitHub。”

代理预期行为：

1. 重复示例 1 中的完整本地检查和提交流程。
2. 在本地提交完成且 `git status` 干净后，执行 `git push origin <当前分支>`。
3. 回复用户：
   - 说明已完成本地提交和远程推送；
   - 概述本次提交的主要内容；
   - 如有可用的远程仓库/PR 链接，可以提示用户到对应位置查看。

